---
title: "Data Challenge 2"
author: "Saskia Gianola"
date: "January 2025"
format: 
  html:
    embed-resources: true
    fig_caption: true
    fig-align: center
    highlight: tango
    number-sections: false
    theme: journal
    toc: true
    toc_depth: 2
    toc_float: true
    code-fold: true
execute:                      # Set global options for execution of code blocks
  echo: false
  warning: false
  message: false
---
```{r results='hide', message=FALSE, warning=FALSE}
library(sf)
library(rnaturalearth)
library(igraph)
library(tidygraph)
library(tidyverse)
library(sfnetworks)
library(spdep)
library(reshape2)
library(broom)
library(viridis)
library(deldir)
library(dbscan)
library(gapminder)
library(caret)
library(flextable)
library(titanic)
library(pscl)
library(terra)
library(leaflet)
library(spatialreg)
library(lme4)
library(lmerTest)
library(ggeffects)
library(tmap)
```
# Introduction 
This file includes the assignments, code and interpretation of Data Challenge 2. The code was elaborated as collaboration between Sarah Wirth and Saskia Gianola. Each person has invested about 25 hours into this project. ChatGPT has been used to create and adapt code for this data challenge, but not for the interpretation. 

# Part 1 Modeling networks
## Task 1
Describe the bicycle network. In particular, discuss properties that emerged in this week’s
session, such as:

* What are the attributes of the nodes and edges? 
* How many nodes and edges are present in the network? 
* Do the edges have geometries themselves, or are they merely relations between nodes that possess geometries?
* Is the network connected? (Largely) planar? Weighted? Does it contain self-loops? 

```{r results='hide'}
# read data
biking_network <- readRDS("biking_network.rds")
boundary <-st_read("Session2/Zurich_city_boundary_2024.gpkg")
districts <-st_read("Session2/Zurich_city_districts_2024.gpkg")

biking_network

# Extract attributes of edges
edge_attr(biking_network)

# Extract attributes of vertices
vertex_attr(biking_network)
```

The bicycle network constists of 24191 nodes and 29694 edges. It is undirected. The attributes of the edges are the name of the street, information about whether it is a bridge or a tunnel or neither, as well as the level of the highway. The geometry is linestring. Also, there is information about the from and to points, and the OSM ID. The vertices are points with an id but without further attributes. The network is largely planar and does not contain self loops. It is not weighted.

## Task 2
Create a regular grid (hexagonal or rectangular, your choice) that covers the same area as the bike network. Your grid should have a suitable resolution. As a guideline, when overlaid on the bike network, your grid should be large enough to group nodes belonging to the same intersection together, while being small enough to separate the various districts (Quartiere). You can derive a suitable resolution from the bike network data, such as by using k-nearest-neighbour distances between intersections, or you can provide a rationale for your choice. In either case, please explain your reasoning. Finally, convert your grid into a valid spatial network using an appropriate definition of spatial neighbourhood.

```{r}
# activate nodes and edges and save as sf object
nodes_sf <- biking_network |> 
  activate("nodes") |> 
  st_as_sf()

edges_sf <- biking_network |> 
  activate("edges") |> 
  st_as_sf()

# activate nodes and edges and save as network
nodes <- biking_network |> 
  activate("nodes") 

edges <- biking_network |> 
  activate("edges")

# getting coordinates from nodes
nodes_cor<-st_coordinates(nodes)
```

```{r}
# take a look at distances within network
kNNdistplot(nodes_cor, k=1)
abline(h = 100, col = "red")
abline(h = 75, col = "orange")
abline(h = 50, col = "darkgreen")
abline(h = 25, col = "blue")
abline(h = 10, col = "purple")

# create bounding box from edges of network
bbox <- biking_network |>
  activate("edges") |>
  st_bbox()|> 
  sf::st_as_sfc()

# create grid with resolution of 50 m
hex_grid <- sf::st_make_grid(bbox, what = "polygons", 
                          cellsize = 50, square = FALSE, flat_topped = FALSE)
```

If I take a look at the kNN distance plot, a threshold of 50 to 75 m makes sense. In order to decide we took a look at the Niderdörfli. Within this area, the streets are rather short. After measuring some edges we decided to use a threshold of 50 m. We first created both a hexagonal and rectangular grid, but deleted the rectangular one as we proceeded. 

# Part 2 Network measures
## Task 3
Have you ever cycled in Zürich? Compute and plot the optimal path from the starting point to the endpoint of a cycling route you are familiar with. You can use the biking_network.rds provided in Session 06, or adapt the CycleNetwork.rmd to create your own network. Compare the route inferred by the network with your preferred route.

I have never cycled in the city of Zurich, but I am interested in the path from the main station to Oerlikon. I will try to compute the path between those two points. 

```{r}
# determine start and end points
oerlikon_bhf <- st_point(c(2683413.48, 1251832.48)) |> 
  st_sfc(crs = 2056)

ZurichHB <- st_point(c(2683125.01, 1247960.84)) |> 
  st_sfc(crs = 2056)

oerlikon_bhf_vertex <- st_nearest_feature(oerlikon_bhf, nodes)

ZurichHB_vertex <- st_nearest_feature(ZurichHB, nodes)

# find shortest path
path <- shortest_paths(
  graph = biking_network,
  from = oerlikon_bhf_vertex,
  to = ZurichHB_vertex,
  output = 'both')

# Turn the shortest path into a graph
graph <- biking_network |> 
    subgraph.edges(eids = path$epath |>  unlist(), 
                   delete.vertices = FALSE) |> 
    as_sfnetwork(node_key = "id")

graph_4326 <- graph |> 
  st_transform(crs = 4326) |> 
  activate(edges) |> 
  st_as_sf()

leaflet() |> 
  addTiles() |> 
  addPolylines(data = graph_4326,
               color = "red",
               weight = 4)
```
The calculated path differs a lot from what google maps suggets when you ask for a route for a bike from Zurich main station to Zurich Oerlikon. It seems that the shortest path includes a lot of crossings over big streets, which I would try to avoid. Also, the coordinates for the start and endpoint seem to habe a big influence on the route. Near the main station, the path makes a rather funny excursion to the Bahnhofquai and I'm not sure why that happend. Nevertheless, I think until the crossing of the Bucheggstrasse I would have chosen a similar route. 

## Task 4
In a future week, we will estimate bike traffic based on network measures. This week, choose one network measure to inform your traffic estimates. You may use any network measure you wish, but you must justify your choice. Consider the following questions:

* Why is it reasonable to assume that the measure you choose correlates with the amount of bike traffic? 
* What potential problems might arise with this measure? For example, the network contains many parallel paths in close proximity, which could influence measures that rely on shortest-path computations. 
* Plot your chosen measure for the network.

I chose the betweenness centrality measure as it counts how many shortest paths go through a vertex. I assume that the bikers take the shortest path from A to B and therefore this measure seems appropriate. One possible problem might be that bikers choose a longer path that has less traffic or red lights. It is also possible that the shortest path has a lot of elevation that bikes might be wanting to avoid. Nevertheless, I think this measure correlates most with the amount of bike traffic. When there are different paths going parallel to each other, I would choose the one with least traffic, whereas the algorithm chooses the shortest path. 

```{r}
# Compute the betweenness centrality
biking_network_nodes <- nodes |> 
  activate("nodes") |> 
  mutate(btw = betweenness(biking_network))

biking_network_edges <- edges |> 
  activate("edges") |> 
  mutate(btw = edge_betweenness(biking_network))

biking_network_nodes_sf <- nodes |> 
  activate("nodes") |> 
  mutate(btw = betweenness(biking_network)) |> 
  st_as_sf()

biking_network_edges_sf <- edges |> 
  activate("edges") |> 
  mutate(btw = edge_betweenness(biking_network)) |> 
  st_as_sf()
```

::: {.panel-tabset .nav-pills}

## betweenness centrality of nodes
```{r}
ggplot() +
  geom_sf(data = districts, fill = "lightgrey", color = NA) +
  geom_sf(data = biking_network_edges |>  activate(edges) |>  as_tibble() |>  st_as_sf(), 
          col = 'white') +
  geom_sf(data = biking_network_nodes |>  activate(nodes) |>  as_tibble() |>  st_as_sf(), 
          aes(col=btw), size = 0.5) +  
  scale_color_viridis_c(option = "turbo", name = "Betweenness (Nodes)") +
  theme_void()
```

## betweenness centrality of edges
```{r}
ggplot() +
  geom_sf(data = districts, fill = "lightgrey", color = NA) +
  geom_sf(data = biking_network_edges_sf, aes(color = btw), size = 1) +
  scale_color_viridis_c(option = "turbo", name = "Betweenness (Edges)") +
  theme_void()
```
:::

These plots show the betweenness centrality of the nodes as well as the edges. On this scale, there is not much to be recognised, nevertheless you can see points with higher betweenness centrality from Kreis 12 all the way down to Kreis 3. Looking at the betweenness centrality of the edges, this becomes even clearer. There is that one road from Kreis 12 to Kreis 3 as well as the one coming up from Kreis 2 trough the centre and along the river. 

## Task 5 
A new bicycle infrastructure project, the “Stadttunnel” (https://www.stadt-zuerich.ch/site/velo/de/index/st adttunnel.html), is under construction, connecting the coordinates (8.53619°E, 47.37768°N) with (8.53783°E, 47.38024°N) beneath the station. Analyse how this project affects the network measure you selected in Task 4, and visualise the changes. Depending on when you retrieved the data from OSM, the Stadttunnel might already be included in the network or not. If you encounter difficulties removing or adding the edge, please refer to the script remove_or_add_edge.r available on OLAT.

```{r results='hide'}
# test if the Stadttunnel is already included in my network
# Define a bounding box around Zurich HB.
bbox_hb <- 
  st_sf(geom = st_sfc(st_point(c(8.5360556,  47.3798416)), 
                      st_point(c(8.5400802, 47.3770750))), crs = 4326) |>
  st_transform(crs = 2056) |>
  st_bbox() |>
  st_as_sfc()

# Locate the Stadttunnel
stadttunnel <- biking_network |> 
  activate(edges) |>
  st_as_sf() |>
  filter(tunnel == 1) |>
  filter(highway == "construction") |>
  st_filter(bbox_hb, .predicates = st_intersects)

# there is already an edge called velotunnel that is under construction
# we need to remove the tunnel from the network in order to determine the influence on the centrality. 

# Use the unique from and to IDs from the previous query to remove the tunnel.
# (Explicitly specifying from and to is not strictly necessary but clarifies our intent.)

biking_network_no_stadttunnel <- biking_network |> 
  activate(edges) |> 
  filter(from != stadttunnel |> pull (from), 
         to != stadttunnel |> pull (to)) 

# Check if the Stadttunnel was successfully removed.
biking_network_no_stadttunnel |> 
  activate(edges) |>
  st_as_sf() |>
  filter(tunnel == 1)|>
  filter(highway == "construction") |>
  st_filter(bbox_hb, .predicates = st_intersects)

# the output is empty, meaning the Stadttunnel has been removed successfully

# calculate betweenness centrality without Stadttunnel
biking_network_no_stadttunnel <- biking_network_no_stadttunnel |> 
  activate("nodes") |> 
  mutate(btw = betweenness(biking_network_no_stadttunnel))

biking_network_no_stadttunnel_sf <- biking_network_no_stadttunnel |> 
  activate("edges") |> 
  mutate(btw = edge_betweenness(biking_network_no_stadttunnel)) |> 
  st_as_sf()
```

::: {.panel-tabset .nav-pills}
## Betweenness centrality nodes for center of Zürich with the Stadttunnel
```{r}
ggplot() +
  geom_sf(data = districts, fill = "lightgrey", color = NA) +
  # Plot the entire network
  geom_sf(data = biking_network_edges |>  activate(edges) |>  as_tibble() |>  st_as_sf(), 
          col = 'white') +
  geom_sf(data = biking_network_nodes |>  activate(nodes) |>  as_tibble() |>  st_as_sf(), 
          aes(size=btw), col = "black") +  
  coord_sf(xlim = c(2682100, 2683680), ylim = c(1247700, 1248800), expand = FALSE) + 
  theme_void()
```

## Betweenness centrality edges for center of Zürich with the Stadttunnel
```{r}
ggplot() +
  geom_sf(data = districts, fill = "lightgrey", color = NA) +
  geom_sf(data = biking_network_edges_sf, aes(color = btw), size = 10) +
  scale_color_viridis_c(option = "turbo", name = "Betweenness (Edges)") +
  coord_sf(xlim = c(2682100, 2683680), ylim = c(1247700, 1248800), expand = FALSE) +
  theme_void() +
  theme(
    legend.position = "bottom",
    legend.box = "horizontal"
  )
```

## Betweenness centrality nodes for center of Zürich without the Stadttunnel
```{r}
ggplot() +
  geom_sf(data = districts, fill = "lightgrey", color = NA) +
  # Plot the entire network
  geom_sf(data = biking_network_no_stadttunnel |>  activate(edges) |>  as_tibble() |>  st_as_sf(), 
          col = 'white') +
  geom_sf(data = biking_network_no_stadttunnel |>  activate(nodes) |>  as_tibble() |>  st_as_sf(), 
          aes(size=btw), col = "black") +  
    coord_sf(xlim = c(2682100, 2683680), ylim = c(1247700, 1248800), expand = FALSE) + 
  theme_void()
```

## Betweenness centrality edges for center of Zürich without the Stadttunnel
```{r}
ggplot() +
  geom_sf(data = districts, fill = "lightgrey", color = NA) +
  geom_sf(data = biking_network_no_stadttunnel_sf, aes(color = btw), size = 3) +
  scale_color_viridis_c(option = "turbo", name = "Betweenness (Edges)") +
  coord_sf(xlim = c(2682100, 2683680), ylim = c(1247700, 1248800), expand = FALSE) +
  theme_void() +
  theme(
    legend.position = "bottom",
    legend.box = "horizontal"
  )
```
:::

The plots show the betweenness centrality of the nodes and edges around the main station with and without the Stadttunnel. We decided to fokus on the area around the mainstation in order to make the differences visible. With the Stadttunnel, the nodes on the Sihlquai, Kasernenstrasse and Platzspitzbrücke are higher. Without the Stadttunnel, the nodes on the Gessnerallee, Bahnhofplatz, Bahnhofstrasse and all the way to Neumühlenquai are higher. Additionaly, the nodes at the Walchebrücke have a higher centrality. Looking at the betweenness centrality of the edges shows a similar picture. With the Stadttunnel, there is this new route from Kasernenstrasse under the main station and along Platzspitz all the way up to Platzspitzbrücke and Drahtschmidlisteg. Without the Stadttunnel, the route along Gessnerallee, Bahnhofplatz, Bahnhofbrücke and Neumühlenquai or Bahnhofquai, Walchebrücke and Walchestrasse have higher centrality. The Stampfenbackstrasse also has higher centrality without the Stadttunnel. It can be concluded that the Stadttunnel offers a more direct way from Kreis 4 to Kreis 6.

# Part 3 Spatial Autocorrelation
## Task 6 
Determine the number of bike accidents occurring in each grid cell. Use the function st_contains if your grid is made up of polygons, or st_nearest_feature if it consists of points. Plot the Getis-Ord G i statistic to visualize accident counts per cell. Assess whether the results are significant and identify where accident hot spots are located. If you recognize the locations, consider whether the hot spots share common characteristics or features.

```{r results='hide'}
# read tree data
baumkataster_shp <- st_read("baumstandorte/gsz.baumkataster_baumstandorte.shp")
st_crs(baumkataster_shp)

# remove columns that are not needed
colnames(baumkataster_shp)
baumkataster_shp[3:16] <- list(NULL)
colnames(baumkataster_shp)

# read accident data
accidents <- st_read("roadtrafficaccidentlocations.gpkg")
st_crs(accidents)

# only keep bike accidents
bike_accidents <- accidents |> 
  filter(AccidentInvolvingBicycle == "true")

# remove columns that are not needed
colnames(bike_accidents)
bike_accidents[3:6] <- list(NULL)

colnames(bike_accidents)
bike_accidents[4:10] <- list(NULL)

colnames(bike_accidents)
bike_accidents[5:8] <- list(NULL)

colnames(bike_accidents)
bike_accidents[10:22] <- list(NULL)

colnames(bike_accidents)
```

```{r}
# grid to sf
hex_grid_sf <- st_as_sf(hex_grid, crs = 2056)

count_acc_hex <-st_contains( hex_grid_sf,bike_accidents)
counts <- lengths((count_acc_hex))

acc_in_hex <- hex_grid_sf
acc_in_hex$counts <- counts

# Calculate centroid and apply count to it
hex_centro <- st_centroid(hex_grid_sf)
hex_centro_acc <-st_join(hex_centro,acc_in_hex)
neighbors <- knn2nb(knearneigh(st_coordinates(hex_centro_acc), k = 18))#to reduce computing effort we define the neigbors as only the 6 neighbor adjacent neigbor- cells

weights <- nb2listw(neighbors, style = "W", zero.policy = TRUE)

gi_values <- localG(hex_centro_acc$counts, listw = weights)
hex_centro_acc$gi_value <- gi_values

hex_centro_acc$gi_value_no_localG <- as.numeric(hex_centro_acc$gi_value)#get rid of local g class

hex_centro_acc_4326<- st_transform(hex_centro_acc, crs = 4326)
```

## Getis-Ord G i statistic
```{r}
leaflet(hex_centro_acc_4326) |> 
  addProviderTiles("Esri.WorldTopoMap", group = "Terrain") |> 
  addCircleMarkers(
    color = ~colorNumeric("RdBu", hex_centro_acc_4326$gi_value_no_localG, reverse = TRUE)
    (hex_centro_acc_4326$gi_value_no_localG),
    fillOpacity = 0.7,
    radius = 3,
    stroke = FALSE,
    popup = ~paste("Gi-Value: ", round(gi_value_no_localG, 2))) |>  
  addLegend(
    position = "bottomright",
    pal = colorNumeric("RdBu", hex_centro_acc_4326$gi_value_no_localG, reverse = TRUE),
    values = hex_centro_acc_4326$gi_value_no_localG,
    title = "Getis-Ord Gi-Value",
    opacity = 0.7)
```

There are more accidents around the Central, along the Limmatquai, Langstrasse and Hardbrücke. These are well known locations for a lot of traffic, not only cars but also tram, busses and pedestrian. It seems quite plausible that more accidents happen in these locations. Another hotspot is the Bucheggplatz, where there is also a lot of traffic with public transport. Looking at these hotspots it can be said that when there is a lot of traffic also with trams and busses, there are more accident. This is plausible as bikers can for example get stuck on the tracks of the trams and there are normally a lot of people who walk across the street before looking or thinking. Zooming out a little bit on the map you can also see that more accidents tend to happen along the roads with higher centrality as shown in task 5. 

## Task 7
In a future task, we will predict bike traffic in the network, and for this, we want to check the number of trees along routes. Who knows, maybe cyclists prefer greener routes! For each network edge, count the number of trees nearby. Be careful to avoid double-counting the trees, and be sure to justify your definition of “nearby.”

We chose to buffer the edges with 5 m before joining with the trees. We assume, that if the edge is in the middle of the road, there are 3 m of street, 1 m of sidewalk and 1 m of greenstrip where the trees could be on each side. As our computers could not handle the join over the whole city, we chose to focus on the region of Kreis 1, 4 and 5. We keep this fokus for the remaining of DC2, as it was not possible to take the whole city into account. 

```{r}
# we focus on districts 1, 4 and 5:
centre <- districts |> 
  filter(KNR %in% c(1,4,5))

bbox_centre <- centre |> 
  st_bbox() |> 
  st_as_sfc() 

bbox_centre_sf <- st_sf(geometry = bbox_centre)

# clip all data to the bbox
trees_clipped <- st_intersection(bbox_centre_sf, baumkataster_shp)
bike_accidents_clipped <- st_intersection(bbox_centre_sf, bike_accidents)
biking_network_edges_sf_clipped <- st_intersection(bbox_centre_sf, biking_network_edges_sf)
edges_sf_clipped <- st_intersection(bbox_centre_sf, edges_sf)

# create unique id
biking_network_edges_sf_clipped$uniqueID <- paste(biking_network_edges_sf_clipped$osm_id, biking_network_edges_sf_clipped$from, biking_network_edges_sf_clipped$to, sep = "_")
edges_sf_clipped$uniqueID <- paste(edges_sf_clipped$osm_id, edges_sf_clipped$from, edges_sf_clipped$to, sep = "_")
```


```{r echo=TRUE, collapse=TRUE}
# create buffer around edges, 5 m buffer = 3 m street + 1 m sidewalk, + 1 m buffer
edge_buffer <- st_buffer(edges_sf_clipped, dist = 5)

# find nearest edge for each tree and get osm id
nearest_street <- st_nearest_feature(trees_clipped, edge_buffer)
nearest_street <- edge_buffer$uniqueID[nearest_street]

# add osm id from nearest street to trees
trees_streets <- trees_clipped |> 
  mutate(nearest_street_id = nearest_street)
  
# remove all trees that don't have a street id
trees_streets <- trees_streets[!is.na(trees_streets$nearest_street_id), ]

trees_per_street <- trees_streets |> 
  group_by(nearest_street_id) |> 
  summarise(count_trees = n()) |> 
  st_drop_geometry()
```


## Task 8
Also, for a future task, count the number of accidents along each network edge.

For this task we use the same buffer as in task 7 with the trees. 
```{r, echo=TRUE, collapse=TRUE}
# find nearest edge for each accident and get osm id
nearest_street_acc <- st_nearest_feature(bike_accidents_clipped, edge_buffer)
nearest_street_acc <- edge_buffer$uniqueID[nearest_street_acc]

# add osm id from nearest street to accidents
accidents_streets <- bike_accidents_clipped |> 
  mutate(nearest_street_id = nearest_street_acc)
  
# remove all accidents that don't have a street id
accidents_streets <- accidents_streets[!is.na(accidents_streets$nearest_street_id), ]

acc_per_street <- accidents_streets |> 
  group_by(nearest_street_id) |> 
  summarise(count_acc = n()) |> 
  st_drop_geometry()
```

# Part 4 Generalised Linear Regression
## Task 9
Construct two different models to extrapolate bike traffic on Zurich’s roads. Base your models on the (potentially transformed) centrality measure you computed in Task 4. At least one of your two models should also use the (potentially transformed) tree counts per edge from Task 7. You may use additional predictors from my examples or whatever open data you can find elsewhere. I don’t expect you to go hunting, but if you have a good idea, I will be happy to see it and hopefully include it for future years.
```{r results='hide'}
# read bike count data: Hourly Traffic at Night (`nn`) and Hourly Traffic at Daytime (`nt`).
bike_counts <- readRDS("bike_counts_aggregated.rds")

# join sf of edges containing btw with bike counts, trees and accident points
joined_data <- st_join(biking_network_edges_sf_clipped, bike_counts, left = TRUE, largest = TRUE)
joined_data <- left_join(x = joined_data, y = trees_per_street, by = join_by(uniqueID == nearest_street_id))
joined_data <- left_join(x = joined_data, y = acc_per_street, by = join_by(uniqueID == nearest_street_id))

# clean data 
colnames(joined_data)
joined_data$btw[joined_data$btw == 0] <- NA
joined_data$highway <- factor(joined_data$highway)
levels(joined_data$highway)
```
::: {.panel-tabset .nav-pills}

## linear regression model where betweenness predicts traffic
```{r}
# compute linear regression 
linear_btw <- lm(per_day ~ btw, data = joined_data) # y ~ x

# Retrieve the slope and intercept of the model
linear_m <- linear_btw$coefficients["btw"]
linear_b <- linear_btw$coefficients["(Intercept)"]

# Plot the linear relationship between btw and traffic
ggplot(joined_data) +
  geom_point(aes(x = btw, y = per_day)) +
  geom_abline(slope = linear_m, intercept = linear_b, color = "blue", linetype = "solid") +
  xlab("Betweenness centrality") +
  ylab("Traffic per day") +
  theme_minimal()
```
This linear regression is not suited to predict the traffic. 

## linear regression model where log betweenness predicts traffic
```{r}
# Compute a linear regression model where log btw predicts traffic
loglinear_btw <- lm(per_day ~ log(btw), data = joined_data)
loglinear_m <- loglinear_btw$coefficients["log(btw)"]
loglinear_b <- loglinear_btw$coefficients["(Intercept)"]

# Plot the linear relationship between log btw and traffic
ggplot(joined_data) +
  geom_point(aes(x = btw, y = per_day)) +
    geom_abline(slope = loglinear_m, intercept = loglinear_b, color = "blue", linetype = "solid") +
  scale_x_continuous(trans = "log") +
  xlab("Betweenness centrality") +
  ylab("Traffic per day") +
  theme_minimal()

# Compute the RMSE of the linear and log-linear model
rmse_linear <- sqrt(mean(residuals(linear_btw)^2))
rmse_loglinear <- sqrt(mean(residuals(loglinear_btw)^2))
```
Also the log of betweenness is not able to predict traffic.

## comparison of the two models
```{r message=TRUE}
summary(linear_btw)
summary(loglinear_btw)

# both approaches are not useful to predict traffic
```
Both approaches show a high p value and a low adjusted R-squared value, meaning they aer not useful to predict traffic. 

## linear regression model where amount of trees predicts traffic
```{r}
# compute linear regression 
linear_tree <- lm(per_day ~ count_trees, data = joined_data) # y ~ x

# Retrieve the slope and intercept of the model
linear_m <- linear_tree$coefficients["count_trees"]
linear_b <- linear_tree$coefficients["(Intercept)"]

# Plot the linear relationship between btw and traffic
ggplot(joined_data) +
  geom_point(aes(x = count_trees, y = per_day)) +
  geom_abline(slope = linear_m, intercept = linear_b, color = "blue", linetype = "solid") +
  xlab("Tree count") +
  ylab("Traffic per day") +
  theme_minimal()
```
This linear regression is not suited to predict the traffic. 

## linear regression model where log amount of trees predicts traffic
```{r}
# Compute a linear regression model where log btw predicts traffic
loglinear_tree <- lm(per_day ~ log(count_trees), data = joined_data)
loglinear_m <- loglinear_tree$coefficients["log(count_trees)"]
loglinear_b <- loglinear_tree$coefficients["(Intercept)"]

# Plot the linear relationship between log btw and traffic
ggplot(joined_data) +
  geom_point(aes(x = count_trees, y = per_day)) +
    geom_abline(slope = loglinear_m, intercept = loglinear_b, color = "blue", linetype = "solid") +
  scale_x_continuous(trans = "log") +
  xlab("Tree count") +
  ylab("Traffic per day") +
  theme_minimal()

# Compute the RMSE of the linear and log-linear model
rmse_linear <- sqrt(mean(residuals(linear_tree)^2))
rmse_loglinear <- sqrt(mean(residuals(loglinear_tree)^2))
```

## comparison of the two models
```{r message=TRUE}
summary(linear_tree)
summary(loglinear_tree)

# both approaches are not useful to predict traffic
```
Also the tree count is not able to predict traffic. Both approaches are similarly bad as the prevoius ones. 
<!-- ## Residual plot -->
<!-- ```{r} -->
<!-- # Add the residuals of the log-linear model to the original data -->
<!-- loglinear_res <- joined_data |>    -->
<!--   mutate(residuals = per_day - loglinear$fitted.values) -->

<!-- # Plot the residuals -->
<!-- ggplot(loglinear_res) + -->
<!--   geom_point(aes(x = btw, y = residuals, size = count_trees, colour = highway)) + -->
<!--   scale_x_continuous(trans = "log", -->
<!--                      name = "Betweenness centrality") + -->
<!--   xlab("Betweenness centrality") + -->
<!--   ylab("Traffic per day") + -->
<!--   theme_minimal() -->
<!-- ``` -->
<!-- The residual plot shows no clear picture what factors could predict traffic. In a next step, I try to use the highway type to predict traffic.  -->

<!-- ## linear regression model where highway type predicts traffic -->
<!-- ```{r} -->
<!-- # Compute a linear regression model where highway type predicts traffic -->
<!-- categorical <- lm(per_day ~ count_trees + 0, data = joined_data) -->
<!-- rmse_categorical <- sqrt(mean(residuals(categorical)^2))  -->

<!-- # Plot the mean traffic per highway type  -->
<!-- ggplot(joined_data, aes(x = count_trees, y = per_day)) + -->
<!--   geom_boxplot() + -->
<!--   stat_summary(fun = mean, geom = "point", col = "pink1") +  -->
<!--   xlab("Betweenness centrality") + -->
<!--   ylab("Traffic per day") + -->
<!--   theme_minimal() -->
<!-- ``` -->
<!-- These boxplots show that highways  -->

<!-- ## linear regression model where log betweenness and highway type predict traffic  -->
<!-- ```{r} -->
<!-- # Compute a linear regression model where log btw and highway type predict traffic  -->
<!-- multivariate <- lm(per_day ~ log(btw) + highway, data = joined_data) -->
<!-- rmse_multivariate <- sqrt(mean(residuals(multivariate)^2)) -->

<!-- multivariate_m <- multivariate$coefficients["log(btw)"] -->
<!-- multivariate_b <- multivariate$coefficients["(Intercept)"] -->

<!-- multivariate_bs <- c(multivariate_b,  -->
<!--                      multivariate_b + multivariate$coefficients["highwayliving_street"], -->
<!--                      multivariate_b + multivariate$coefficients["highwaypath"], -->
<!--                      multivariate_b + multivariate$coefficients["highwayresidential"], -->
<!--                      multivariate_b + multivariate$coefficients["highwaysecondary"]) -->

<!-- # Plot the regression lines  -->
<!-- ggplot(joined_data) + -->
<!--   geom_point(aes(x = btw, y = per_day, colour = highway)) + -->
<!--   geom_line( -->
<!--     data = data.frame(x = seq(300, 1000000000, by = 100000)), -->
<!--     aes(x = x, y = multivariate_m * log(x) + multivariate_bs[1], color = "highwayliving_street")) + -->
<!--   geom_line( -->
<!--     data = data.frame(x = seq(300, 1000000000, by = 100000)), -->
<!--     aes(x = x, y = multivariate_m * log(x) + multivariate_bs[2], color = "highwaypath")) + -->
<!--   geom_line( -->
<!--     data = data.frame(x = seq(300, 1000000000, by = 100000)), -->
<!--     aes(x = x, y = multivariate_m * log(x) + multivariate_bs[3], color = "highwayresidential")) + -->
<!--   geom_line( -->
<!--     data = data.frame(x = seq(300, 1000000000, by = 100000)), -->
<!--     aes(x = x, y = multivariate_m * log(x) + multivariate_bs[4], color = "highwaysecondary")) + -->
<!--   scale_x_continuous(trans = "log") + -->
<!--   xlab("Betweenness centrality") + -->
<!--   ylab("Traffic per day") + -->
<!--   theme_minimal() -->
<!-- ``` -->
:::

## Task 10
Compare the two models using at least one quantitative model comparison method. 

```{r}
# Compute the AIC and BIC
BIC <- c(BIC(linear_btw), BIC(loglinear_btw), BIC(linear_tree), BIC(loglinear_tree))
AIC <- c(AIC(linear_btw), AIC(loglinear_btw), AIC(linear_tree), AIC(loglinear_tree))

model_performance <- data.frame(model = c("linear_btw", "loglinear_btw", "linear_tree",
                                          "loglinear_tree"),
                                BIC = BIC,
                                AIC = AIC)

# Visualise the AIC and BIC for all models in a table
flextable(model_performance)
```
The comparison of the linear and loglinear models with betweenness and count of trees to predict traffic shows that the AIC and BIC values of the linear and loglinear approach with the treecount is much lower than for the betweenness. But considering the summaries they are not able to predict traffic. It has to mentioned, that there are very little datapoints for the traffic count. Additionally, the tree count columns contains a lot of NAs that are ignored. This might be the reason for the much lower AIC and BIC values but the low adjusted R-quared and high p-value. There is one street where seem to be over 400 trees. This might be along the river. We assume that this datapoint affects the performance of the model as well. 

## Task 11
You counted the number of accidents along each network edge in Task 8. Apply Poisson regression to predict the number of bike accidents along each edge based on the (potentially transformed) centrality measure you computed in Task 4. Based on the model’s prediction, visualize the predicted probability that no accident occurs along each network edge.

For further evaluation, we decided to replace all NA within the column of the amount of accidents with 0, as we assume that there are no accidents if they were not reported. Additionally, we decided to remove all cases where the betweenness was NA. We thought about removing all cases with NA trees as well or replacing them with 0, but none of the two approaches made sense so we decided to limit the modification to the points mentioned above. This cleanup was necessary for the models to run without errors. 

```{r message=TRUE}
joined_data_null <- joined_data |>
  mutate(count_acc = replace_na(count_acc, 0)) |>
  filter(!is.na(btw))

poisson_model <- glm(count_acc ~ btw, data = joined_data_null, family = "poisson")
summary(poisson_model)
```

The summary of the poission model shows a high significance but very little influence of betweenness on the accidents. The difference between the null deviance an residual deviance is small, but shows that the model is a bit better. The AIC is very high, but needs comparision to be interpreted well. 

```{r}
# Retrieve coefficients
intercept_poisson <- poisson_model$coefficients[1]
slope_poisson <- poisson_model$coefficients[2]

joined_data_null$lambda <- exp(intercept_poisson + slope_poisson * joined_data_null$btw)
joined_data_null$p_no_accident <- exp(-joined_data_null$lambda)

# plot data
ggplot(joined_data_null) +
  geom_sf(aes(color = p_no_accident), size = 3) +
  scale_color_viridis_c(name = "Predicted probability", option = "H", direction = -1) +
  labs(title = "Predicted probability that no accident occurs per edge") +
  theme_void()
```

The predicted probability that no accident occurs shows similar results as the hotspot analysis from task 6. On roads with more traffic, also more trams and busses, there are more accidents and the probability that an accident occurs is higher than on streets with less traffic. Intresting and worth mentioning is that this model predicts that the probability that an accident happens in the Stadttunnel is a bit higher. I assume this is due to the fact that we use betweenness as predictor. 

# Part 5 Spatial Regression
## Task 12
Construct a linear regression model to predict the number of accidents along network edges based on centrality measures and/or tree counts. You can freely transform variables and add other independent variables to seek a better model. Are the residuals spatially autocorrelated? (Note: Since the number of accidents is count data, Poisson regression makes more sense than simple linear regression, as you did in Task 11. However, use a simple linear regression model for this task so that you can compare the model performance against spatial regression models in Task 13).

::: {.panel-tabset .nav-pills}
## Plot to see connections
```{r}
# first we plot the data
par(mfrow = c(1,2))
plot(joined_data_null$count_acc~joined_data_null$btw)
plot(joined_data_null$count_acc~joined_data_null$count_trees)

```
In these plots we see the how the accident count behaves compared to the betweenness in the first plot and the amount of trees in the second plot.  

## different models
These are the different models we created for this task
```{r echo=TRUE}
lm_betweenness <-lm(formula = count_acc ~ btw, data = joined_data_null)
lm_trees <-lm(formula = count_acc ~ count_trees, data = joined_data_null)
lm_betweenness_trees <-lm(formula = count_acc ~ btw + count_trees, data = joined_data_null)
```

## lm betweenness
```{r}
# plot lm_betweenness
ggplot(joined_data_null, aes(x = btw, y = count_acc)) +
  geom_point(color = "black") +  
  geom_smooth(method = "lm", color = "blue") +  
  labs(x = "Betweenness centrality",
       y = "Amount of accidents") +
  theme_minimal()

par(mfrow = c(2, 2))
plot(lm_betweenness)
```
These plots are used to test whether the requirements for a linear model are fulfilled. There is no variance homogeneity. The residuals are not normally distributed (top right). These results are not surprising as the data was not transformed. 

## lm trees
```{r}
par(mfrow = c(1, 1))
# plot lm_trees
ggplot(joined_data_null, aes(x = count_trees, y = count_acc)) +
  geom_point(color = "black") +  
  geom_smooth(method = "lm", color = "blue") +  
  labs(x = "Amount of trees",
       y = "Amount of accidents") +
  theme_minimal()

par(mfrow = c(2, 2))
plot(lm_trees)
```
The plots show a very similar picture as for the lm betweenness. The residuals are not normally distributed. 

## lm betweenness and trees
```{r}
# plot lm_betweenness_trees
par(mfrow = c(2, 2))
plot(lm_betweenness_trees)
```
Again we have very similar plots as in the two prevous cases. 
:::

```{r}
#compare models and choose best model
BIC <- c(BIC(lm_betweenness), BIC(lm_trees), BIC(lm_betweenness_trees), BIC(poisson_model))
AIC <- c(AIC(lm_betweenness), AIC(lm_trees), AIC(lm_betweenness_trees), AIC(poisson_model))

model_performance <- data.frame(model = c("lm_betweenness", "lm_trees", 
                                          "lm_betweenness_trees", "poisson_model"),
                                BIC = BIC, 
                                AIC = AIC)

# Visualise the AIC and BIC for all models in a table
flextable(model_performance)
```
The comparision of the different models show very high AIC and BIC values. The poission model had an AIC of 16960 and is therefore better than the linear model where betweenness explains the amount of accidents, but worse than the model where the trees explain the amount of accidents or where the combination of betweenness and trees explain the amount of accidents. The best model according to this comparision is the one where the combination of betweenness and trees explain the amount of accidents.

```{r results='hide'}
# check for spatial autocorrelation of best model
# Extract residuals and bin them 
joined_data_null_tree <- joined_data_null |> 
  mutate(count_trees = replace_na(count_trees,0))

residuals_lm_btw <- residuals(lm_betweenness) |>
  as_tibble() |>
  setNames("residuals") |>
  mutate(uniqueID = joined_data_null$uniqueID, 
         binned_residuals = cut_interval(residuals, n = 8))

edge_point <- st_centroid(joined_data_null)

joined_data_null <- full_join(edge_point, 
                             residuals_lm_btw, by = "uniqueID")

# Plot the residuals
ggplot(joined_data_null) +
  geom_sf(aes(color = binned_residuals)) + 
  theme_minimal() +
  scale_fill_brewer(name = 'Residuals', palette = "PRGn") +  
  theme(axis.title=element_blank())

# Contiguity neighbours
joined_data_null_knear <- knearneigh(joined_data_null, k = 2)
joined_data_null_nb <- knn2nb(joined_data_null_knear)
summary(joined_data_null_nb)

# any(sapply(joined_data_null_nb, length) == 0)  # FALSE means no isolated points


# Binary spatial weights
joined_data_null_weights <- nb2listw(joined_data_null_nb, style = "B")
# Moran's I 
morans_I_residuals <- lm.morantest(lm_betweenness, listw = joined_data_null_weights,
                                   alternative = "greater")
```

```{r message=TRUE}
morans_I_residuals
```
The results from the Morans I shows a small positive autocorrelation of the data. The observed value is greater than the expected value if there was no autocorrelation. The p value is very low and there is significant autocorrelation. 

## Task 13
Apply a spatial regression model (spatial lag, spatial error, or both) using the same independent variables. Compare the spatial regression model to the simple linear regression model from Task 12.

```{r}
#spatial_lag: does not work because of NA
# lag_joined <- lagsarlm (formula = count_acc ~ btw + count_trees, 
#                            data = joined_data_null_tree, listw = joined_data_null_weights)
# 
# summary(lag_joined)
```
We tried to calculate the spatial lag but as our data still contained a lot of NAs for the tree count, it did not work. We decided to focus on the spatial error instead. 

```{r message=TRUE, echo=TRUE}
# spatial_error
ser_joined  <- spautolm(formula = count_acc ~ btw + count_trees, 
                           data = joined_data_null, listw = joined_data_null_weights)

summary(ser_joined)
```
The summary of the spatial error shows that betweenness and the amount of trees have significant influence on the amount of accidents. Although the influence is significant, the effect is very small. The AIC is again very high. 

```{r}
# compare models
BIC <- c(BIC(lm_betweenness), BIC(lm_trees), BIC(lm_betweenness_trees), BIC(ser_joined))
AIC <- c(AIC(lm_betweenness), AIC(lm_trees), AIC(lm_betweenness_trees), AIC(ser_joined))

model_performance <- data.frame(model = c("lm_betweenness", "lm_trees", "lm_betweenness_trees", "spatial error"),
                                BIC = BIC, 
                                AIC = AIC)

# Visualise the AIC and BIC for all models in a table
flextable(model_performance)
```
The comparison of the models and the spatial error shows that the spatial error outperforms the other models with a delta BIC 15 of and a delta AIC of 21 to the next best model (lm_betweenness_trees). This shows that the inclusion of spatial autocorrelation is needed and justified. 

# Part 6: Spatial Autocorrelation
## Task 14
Define a (linear) mixed effects model to predict the number of accidents at an edge of the bicycle network from the (edge) centrality. You can freely transform variables and add other independent variables like the tree count. As groups for the random effects you can use the different road types (the highway property of the edges).
Note: Observations with NA values are simply omitted by the lmer() function. You could instead
treat them as a separate group using replace_na

```{r}
joined_data_null <- joined_data_null |> 
  mutate(
    btw_scaled = scale(btw),
    count_trees_scaled = scale(count_trees)
  )
```

```{r echo=TRUE}
lmem <- lmer(count_acc ~ btw_scaled + count_trees_scaled +  (1 | highway), data = joined_data_null)
```

```{r message=TRUE}
summary(lmem)
```
The summary of the linear mixed model shows litte but significant effects of betweenness and the count of trees. 

```{r message=TRUE}
anova(lmem)
```
The anova shows that our model is highly significant compared to a model without fixed effects and accounts for random effects of different highway types. 

```{r echo=TRUE}
model_fixed <- lm(count_acc ~ btw_scaled, joined_data_null)

model_random_intercept <- lmer(count_acc ~ btw_scaled + (1 | highway), 
                               data = joined_data_null, REML = F)

model_random <- lmer(count_acc ~  (btw_scaled | highway), 
                     data = joined_data_null, REML = F)

model_mixed <- lmer(count_acc ~ btw_scaled + count_trees_scaled +  (1 | highway), 
                    data = joined_data_null, REML = F)
```

```{r message=TRUE}
AIC(model_fixed, model_random_intercept, model_random, model_mixed)
BIC(model_fixed, model_random_intercept, model_random, model_mixed)
```
The comparision of the four models show that the most complex model has the lowest AIC. The BIC shows very similar results as the AIC. The mixed model seems to explain the amount of accidents best. 
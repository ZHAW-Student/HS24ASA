---
title: "Data Challenge 2"
author: "Saskia Gianola"
date: "January 2025"
format: 
  html:
    embed-resources: true
    fig_caption: true
    fig-align: center
    highlight: tango
    number-sections: false
    theme: journal
    toc: true
    toc_depth: 2
    toc_float: true
execute:                      # Set global options for execution of code blocks
  echo: false
  warning: false
  message: false
---
```{r results='hide', message=FALSE, warning=FALSE}
library(sf)
library(rnaturalearth)
library(igraph)
library(tidygraph)
library(tidyverse)
library(sfnetworks)
library(spdep)
library(reshape2)
library(broom)
library(viridis)
library(deldir)
library(dbscan)
library(gapminder)
library(caret)
library(flextable)
library(titanic)
library(pscl)
library(terra)
library(leaflet)
```
# Part 1 Modeling networks
## Task 1
Describe the bicycle network. In particular, discuss properties that emerged in this week’s
session, such as:
– What are the attributes of the nodes and edges? 
– How many nodes and edges are present in the network? 
– Do the edges have geometries themselves, or are they merely relations between nodes that possess geometries?
– Is the network connected? (Largely) planar? Weighted? Does it contain self-loops? 
```{r results='hide'}
# read data
biking_network <- readRDS("biking_network.rds")
boundary <-st_read("Session2/Zurich_city_boundary_2024.gpkg")
districts <-st_read("Session2/Zurich_city_districts_2024.gpkg")

biking_network

# Extract attributes of edges
edge_attr(biking_network)

# Extract attributes of vertices
vertex_attr(biking_network)

```

The bicycle network constists of 24191 nodes and 29694 edges. It is undirected. The attributes of the edges are the name of the street, information about whether it is a bridge or a tunnel or neither, as well as the level of the highway. The geometry is linestring. Also, there is information about the from and to points, and the OSM ID. The vertices are points without further attributes. The network is largely planar and does not contain self loops. It is not weighted.

## Task 2
Create a regular grid (hexagonal or rectangular, your choice) that covers the same area as the bike network. Your grid should have a suitable resolution. As a guideline, when overlaid on the bike network, your grid should be large enough to group nodes belonging to the same intersection together, while being small enough to separate the various districts (Quartiere). You can derive a suitable resolution from the bike network data, such as by using k-nearest-neighbour distances between intersections, or you can provide a rationale for your choice. In either case, please explain your reasoning. Finally, convert your grid into a valid spatial network using an appropriate definition of spatial neighbourhood.

```{r}
# activate nodes and edges and save as sf object
nodes_sf <- biking_network |> 
  activate("nodes") |> 
  st_as_sf()

edges_sf <- biking_network |> 
  activate("edges") |> 
  st_as_sf()

# activate nodes and edges and save as network
nodes <- biking_network |> 
  activate("nodes") 

edges <- biking_network |> 
  activate("edges")

# getting coordinates from nodes
nodes_cor<-st_coordinates(nodes)
```

```{r}
# take a look at distances within network
kNNdistplot(nodes_cor, k=1)
abline(h = 100, col = "red")
abline(h = 75, col = "orange")
abline(h = 50, col = "darkgreen")
abline(h = 25, col = "blue")
abline(h = 10, col = "purple")

# create bounding box from edges of network
bbox <- biking_network |>
  activate("edges") |>
  st_bbox()|> 
  sf::st_as_sfc()

# create grid with resolution of 50 m
hex_grid <- sf::st_make_grid(bbox, what = "polygons", 
                          cellsize = 50, square = FALSE, flat_topped = FALSE)

```


# Part 2 Network measures
## Task 3
Have you ever cycled in Zürich? Compute and plot the optimal path from the starting point to the endpoint of a cycling route you are familiar with. You can use the biking_network.rds provided in Session 06, or adapt the CycleNetwork.rmd to create your own network. Compare the route inferred by the network with your preferred route.

I have never cycled in the city of Zurich, but I am interested in the path from the mainstation to Oerlikon. I will try to compute the path between those two points. 

```{r}
# determine start and end points
oerlikon_bhf <- st_point(c(2683413.48, 1251832.48)) |> 
  st_sfc(crs = 2056)

ZurichHB <- st_point(c(2683125.01, 1247960.84)) |> 
  st_sfc(crs = 2056)

oerlikon_bhf_vertex <- st_nearest_feature(oerlikon_bhf, nodes)

ZurichHB_vertex <- st_nearest_feature(ZurichHB, nodes)

# find shortest path
path <- shortest_paths(
  graph = biking_network,
  from = oerlikon_bhf_vertex,
  to = ZurichHB_vertex,
  output = 'both')

# Turn the shortest path into a graph
graph <- biking_network |> 
    subgraph.edges(eids = path$epath |>  unlist(), 
                   delete.vertices = FALSE) |> 
    as_sfnetwork(node_key = "id")

# plot shortest path within network
ggplot() +
  geom_sf(data = districts, fill = "lightgrey", color = "black")+
  geom_sf_text(data = districts, aes(label = KNAME),  nudge_x = 100, size = 3)+
  geom_sf(data = graph |>  activate(edges) |> st_as_sf(), lwd = 1, col = 'orange') + 
  theme_void()

```


## Task 4
In a future week, we will estimate bike traffic based on network measures. This week, choose one network measure to inform your traffic estimates. You may use any network measure you wish, but you must justify your choice. Consider the following questions:
• Why is it reasonable to assume that the measure you choose correlates with the amount of bike traffic? • What potential problems might arise with this measure? For example, the network contains many parallel paths in close proximity, which could influence measures that rely on shortest-path computations. • Plot your chosen measure for the network.

I chose the betweenness centrality measure as it counts how many shortest paths go through a vertex. I assume that the bikers take the shortest path from A to B and therefore this measure seems appropriate. One possible problem might be that bikers choose a longer path that has less traffic or red lights. It is also possible that the shortest path has a lot of elevation that bikes might be wanting to avoid. Nevertheless, I think this measure correlates most with the amount of bike traffic.

```{r}
# Compute the betweenness centrality
biking_network_nodes <- nodes |> 
  activate("nodes") |> 
  mutate(btw = betweenness(biking_network))

biking_network_edges <- edges |> 
  activate("edges") |> 
  mutate(btw = edge_betweenness(biking_network))

biking_network_nodes_sf <- nodes |> 
  activate("nodes") |> 
  mutate(btw = betweenness(biking_network)) |> 
  st_as_sf()

biking_network_edges_sf <- edges |> 
  activate("edges") |> 
  mutate(btw = edge_betweenness(biking_network)) |> 
  st_as_sf()


# Plot the betweenness centrality
ggplot() +
  geom_sf(data = districts, fill = "lightgrey", color = NA) +
  # Plot the entire network
  geom_sf(data = biking_network_edges |>  activate(edges) |>  as_tibble() |>  st_as_sf(), 
          col = 'white') +
  geom_sf(data = biking_network_nodes |>  activate(nodes) |>  as_tibble() |>  st_as_sf(), 
          aes(size=btw), col = "black") +  
  theme_void()

# Plot using ggplot
ggplot() +
  geom_sf(data = districts, fill = "lightgrey", color = NA) +
  geom_sf(data = biking_network_edges_sf, aes(color = btw), size = 1) +
  scale_color_viridis_c(option = "turbo", name = "Betweenness (Edges)") +
  theme_void()
```


## Task 5 
A new bicycle infrastructure project, the “Stadttunnel” (https://www.stadt-zuerich.ch/site/velo/de/index/st adttunnel.html), is under construction, connecting the coordinates (8.53619°E, 47.37768°N) with (8.53783°E, 47.38024°N) beneath the station. Analyse how this project affects the network measure you selected in Task 4, and visualise the changes. Depending on when you retrieved the data from OSM, the Stadttunnel might already be included in the network or not. If you encounter difficulties removing or adding the edge, please refer to the script remove_or_add_edge.r available on OLAT.

```{r}
# test if the Stadttunnel is already included in my network
# Define a bounding box around Zurich HB.
bbox_hb <- 
  st_sf(geom = st_sfc(st_point(c(8.5360556,  47.3798416)), 
                      st_point(c(8.5400802, 47.3770750))), crs = 4326) |>
  st_transform(crs = 2056) |>
  st_bbox() |>
  st_as_sfc()

# Locate the Stadttunnel
stadttunnel <- biking_network |> 
  activate(edges) |>
  st_as_sf() |>
  filter(tunnel == 1) |>
  filter(highway == "construction") |>
  st_filter(bbox_hb, .predicates = st_intersects)

# there is already an edge called velotunnel that is under construction
# we need to remove the tunnel from the network in order to determine the influence on the centrality. 

# Use the unique from and to IDs from the previous query to remove the tunnel.
# (Explicitly specifying from and to is not strictly necessary but clarifies our intent.)

biking_network_no_stadttunnel <- biking_network |> 
  activate(edges) |> 
  filter(from != stadttunnel |> pull (from), 
         to != stadttunnel |> pull (to)) 

# Check if the Stadttunnel was successfully removed.
biking_network_no_stadttunnel |> 
  activate(edges) |>
  st_as_sf() |>
  filter(tunnel == 1)|>
  filter(highway == "construction") |>
  st_filter(bbox_hb, .predicates = st_intersects)

# the output is empty, meaning the Stadttunnel has been removed successfully

# calculate betweenness centrality without Stadttunnel
biking_network_no_stadttunnel <- biking_network_no_stadttunnel |> 
  activate("nodes") |> 
  mutate(btw = betweenness(biking_network_no_stadttunnel))

biking_network_no_stadttunnel_sf <- biking_network_no_stadttunnel |> 
  activate("edges") |> 
  mutate(btw = edge_betweenness(biking_network_no_stadttunnel)) |> 
  st_as_sf()

```

::: {.panel-tabset .nav-pills}
## Betweenness centrality nodes for center of Zürich with the Stadttunnel
```{r}
ggplot() +
  geom_sf(data = districts, fill = "lightgrey", color = NA) +
  # Plot the entire network
  geom_sf(data = biking_network_edges |>  activate(edges) |>  as_tibble() |>  st_as_sf(), 
          col = 'white') +
  geom_sf(data = biking_network_nodes |>  activate(nodes) |>  as_tibble() |>  st_as_sf(), 
          aes(size=btw), col = "black") +  
  coord_sf(xlim = c(2682100, 2683680), ylim = c(1247700, 1248800), expand = FALSE) + 
  theme_void()

```

## Betweenness centrality edges for center of Zürich with the Stadttunnel
```{r}
ggplot() +
  geom_sf(data = districts, fill = "lightgrey", color = NA) +
  geom_sf(data = biking_network_edges_sf, aes(color = btw), size = 10) +
  scale_color_viridis_c(option = "turbo", name = "Betweenness (Edges)") +
  coord_sf(xlim = c(2682100, 2683680), ylim = c(1247700, 1248800), expand = FALSE) +
  theme_void() +
  theme(
    legend.position = "bottom",
    legend.box = "horizontal"
  )
```

## Betweenness centrality nodes for center of Zürich without the Stadttunnel
```{r}
ggplot() +
  geom_sf(data = districts, fill = "lightgrey", color = NA) +
  # Plot the entire network
  geom_sf(data = biking_network_no_stadttunnel |>  activate(edges) |>  as_tibble() |>  st_as_sf(), 
          col = 'white') +
  geom_sf(data = biking_network_no_stadttunnel |>  activate(nodes) |>  as_tibble() |>  st_as_sf(), 
          aes(size=btw), col = "black") +  
    coord_sf(xlim = c(2682100, 2683680), ylim = c(1247700, 1248800), expand = FALSE) + 
  theme_void()

```

## Betweenness centrality edges for center of Zürich without the Stadttunnel
```{r}
ggplot() +
  geom_sf(data = districts, fill = "lightgrey", color = NA) +
  geom_sf(data = biking_network_no_stadttunnel_sf, aes(color = btw), size = 3) +
  scale_color_viridis_c(option = "turbo", name = "Betweenness (Edges)") +
  coord_sf(xlim = c(2682100, 2683680), ylim = c(1247700, 1248800), expand = FALSE) +
  theme_void() +
  theme(
    legend.position = "bottom",
    legend.box = "horizontal"
  )
```
:::

# Part 3 Spatial Autocorrelation
## Task 6 
Determine the number of bike accidents occurring in each grid cell. Use the function st_contains if your grid is made up of polygons, or st_nearest_feature if it consists of points. Plot the Getis-Ord G i statistic to visualise accident counts per cell. Assess whether the results are significant and identify where accident hot spots are located. If you recognise the locations, consider whether the hot spots share common characteristics or features.

```{r}
# read tree data
baumkataster_shp <- st_read("baumstandorte/gsz.baumkataster_baumstandorte.shp")
st_crs(baumkataster_shp)

# remove columns that are not needed
colnames(baumkataster_shp)
baumkataster_shp[3:16] <- list(NULL)
colnames(baumkataster_shp)

# read accident data
accidents <- st_read("roadtrafficaccidentlocations.gpkg")
st_crs(accidents)

# only keep bike accidents
bike_accidents <- accidents |> 
  filter(AccidentInvolvingBicycle == "true")

# remove columns that are not needed
colnames(bike_accidents)
bike_accidents[3:6] <- list(NULL)

colnames(bike_accidents)
bike_accidents[4:10] <- list(NULL)

colnames(bike_accidents)
bike_accidents[5:8] <- list(NULL)

colnames(bike_accidents)
bike_accidents[10:22] <- list(NULL)

colnames(bike_accidents)

```


# Getis-Ord G i statistic
```{r}

```


## Task 7
In a future task, we will predict bike traffic in the network, and for this, we want to check the number of trees along routes. Who knows, maybe cyclists prefer greener routes! For each network edge, count the number of trees nearby. Be careful to avoid double-counting the trees, and be sure to justify your definition of “nearby.”

### Reduce extend to make process faster and create unique id

```{r}
# we focus on districts 1, 4 and 5:
centre <- districts |> 
  filter(KNR %in% c(1,4,5))

bbox_centre <- centre |> 
  st_bbox() |> 
  st_as_sfc() 

bbox_centre_sf <- st_sf(geometry = bbox_centre)

# clip all data to the bbox
trees_clipped <- st_intersection(bbox_centre_sf, baumkataster_shp)
bike_accidents_clipped <- st_intersection(bbox_centre_sf, bike_accidents)
biking_network_edges_sf_clipped <- st_intersection(bbox_centre_sf, biking_network_edges_sf)
edges_sf_clipped <- st_intersection(bbox_centre_sf, edges_sf)

# create unique id
biking_network_edges_sf_clipped$uniqueID <- paste(biking_network_edges_sf_clipped$osm_id, biking_network_edges_sf_clipped$from, biking_network_edges_sf_clipped$to, sep = "_")
edges_sf_clipped$uniqueID <- paste(edges_sf_clipped$osm_id, edges_sf_clipped$from, edges_sf_clipped$to, sep = "_")
```


```{r}
# create buffer around edges, 5 m buffer = 3 m street + 1 m sidewalk, + 1 m buffer
edge_buffer <- st_buffer(edges_sf_clipped, dist = 5)

# find nearest edge for each tree and get osm id
nearest_street <- st_nearest_feature(trees_clipped, edge_buffer)
nearest_street <- edge_buffer$uniqueID[nearest_street]

# add osm id from nearest street to trees
trees_streets <- trees_clipped |> 
  mutate(nearest_street_id = nearest_street)
  
# remove all trees that don't have a street id
trees_streets <- trees_streets[!is.na(trees_streets$nearest_street_id), ]

trees_per_street <- trees_streets |> 
  group_by(nearest_street_id) |> 
  summarise(count_trees = n()) |> 
  st_drop_geometry()
  
# # connect trees with buffered edges
# trees <- st_join(edge_buffer, trees_clipped, left = FALSE)
# 
# # calculate distance between trees and edges
# trees$distance <- st_distance(trees, edge_buffer)
# 
# # only keep nearest edge per tree = avoid double counting
# joined_trees <- trees |> 
#   group_by(accident_point_id) |>   
#   slice_min(order_by = distance, n = 1) |>   
#   ungroup()
```


## Task 8
Also, for a future task, count the number of accidents along each network edge.
```{r}
# find nearest edge for each accident and get osm id
nearest_street_acc <- st_nearest_feature(bike_accidents_clipped, edge_buffer)
nearest_street_acc <- edge_buffer$uniqueID[nearest_street_acc]

# add osm id from nearest street to accidents
accidents_streets <- bike_accidents_clipped |> 
  mutate(nearest_street_id = nearest_street_acc)
  
# remove all accidents that don't have a street id
accidents_streets <- accidents_streets[!is.na(accidents_streets$nearest_street_id), ]

acc_per_street <- accidents_streets |> 
  group_by(nearest_street_id) |> 
  summarise(count_acc = n()) |> 
  st_drop_geometry()
```

# Part 4 Generalised Linear Regression
## Task 9
Construct two different models to extrapolate bike traffic on Zurich’s roads. Base your models on the (potentially transformed) centrality measure you computed in Task 4. At least one of your two models should also use the (potentially transformed) tree counts per edge from Task 7. You may use additional predictors from my examples or whatever open data you can find elsewhere. I don’t expect you to go hunting, but if you have a good idea, I will be happy to see it and hopefully include it for future years.

```{r}
# read bike count data: Hourly Traffic at Night (`nn`) and Hourly Traffic at Daytime (`nt`).
bike_counts <- readRDS("bike_counts_aggregated.rds")

# join sf of edges containing btw with bike counts, trees and accident points
joined_data <- st_join(biking_network_edges_sf_clipped, bike_counts, left = TRUE, largest = TRUE)
joined_data <- left_join(x = joined_data, y = trees_per_street, by = join_by(uniqueID == nearest_street_id))
joined_data <- left_join(x = joined_data, y = acc_per_street, by = join_by(uniqueID == nearest_street_id))

# joined_data <- st_join(joined_data, trees, left = TRUE, largest = TRUE)
# joined_data <- st_join(joined_data, accident_points, left = TRUE, join = st_nearest_feature)
# 
# accident_per_joined_edge <- joined_data |>
#   filter(!is.na(AccidentUID)) |>
#   group_by(osm_id.x) |> 
#   mutate(count = n()) |> 
#   ungroup()
# Compute the line graph and evaluate the betweenness centrality of edges
# edges_join <- biking_network |>
#   morph(to_linegraph) |>
#   mutate(edge_btw = centrality_betweenness(weight = NULL, normalized = T)) |>
#   unmorph() |> 
#   st_as_sf()
# 
# edges_join2 <- biking_network |>
#   morph(to_linegraph) |>
#   mutate(edge_btw = centrality_betweenness(weight = NULL, normalized = T)) |>
#   unmorph() |> 
#   st_as_sf()
# 
# # join with biking network amount of trees and amount of accidents
# edges_join <- st_join(edges_join, bike_counts, left = TRUE, largest = TRUE) 
# edges_join <- st_join(edges_join, trees, left = TRUE, largest = TRUE)
# edges_join <- st_join(edges_join, accident_points, left = TRUE, join = st_nearest_feature)

# accident_per_joined_edge <- edges_join |>
#   filter(!is.na(AccidentUID)) |>
#   group_by(osm_id.x) |> 
#   mutate(count = n()) |> 
#   ungroup()

# edges_join <- biking_network |> 
#   activate("edges") |> 
#   st_as_sf()
# 
# edges_join_graph <- biking_network |> 
#   activate("edges")
# biking_network_btw <- biking_network |> 
#   activate("nodes") |> 
#   mutate(btw = betweenness(biking_network))|> 
#   st_as_sf()
#
# edges_join <- st_join(edges_join, biking_network_btw, left = TRUE, largest = TRUE)

# clean data 
colnames(joined_data)
joined_data$btw[joined_data$btw == 0] <- NA
joined_data$highway.x <- factor(joined_data$highway)
levels(joined_data$highway)

```


```{r}
# compute linear regression 
linear <- lm(per_day ~ btw, data = joined_data) # y ~ x

# Retrieve the slope and intercept of the model
linear_m <- linear$coefficients["btw"]
linear_b <- linear$coefficients["(Intercept)"]

# Plot the linear relationship between btw and traffic
ggplot(joined_data) +
  geom_point(aes(x = btw, y = per_day)) +
  geom_abline(slope = linear_m, intercept = linear_b, color = "blue", linetype = "solid") +
  xlab("Betweenness centrality") +
  ylab("Traffic per day") +
  theme_minimal()


# Compute a linear regression model where log btw predicts traffic
loglinear <- lm(per_day ~ log(btw), data = joined_data)
loglinear_m <- loglinear$coefficients["log(btw)"]
loglinear_b <- loglinear$coefficients["(Intercept)"]

# Plot the linear relationship between log btw and traffic
ggplot(joined_data) +
  geom_point(aes(x = btw, y = per_day)) +
    geom_abline(slope = loglinear_m, intercept = loglinear_b, color = "blue", linetype = "solid") +
  scale_x_continuous(trans = "log") +
  xlab("Betweenness centrality") +
  ylab("Traffic per day") +
  theme_minimal()

# Compute the RMSE of the linear and log-linear model
rmse_linear <- sqrt(mean(residuals(linear)^2))
rmse_loglinear <- sqrt(mean(residuals(loglinear)^2))

rmse_linear
rmse_loglinear

# Show summary 
summary(linear)
summary(loglinear)

# both approaches are not useful to predict traffic

# Add the residuals of the log-linear model to the original data
loglinear_res <- joined_data |>   
  mutate(residuals = per_day - loglinear$fitted.values)

# Plot the residuals
ggplot(loglinear_res) +
  geom_point(aes(x = btw, y = residuals, size = count_trees, colour = highway)) +
  scale_x_continuous(trans = "log",
                     name = "Betweenness centrality") +
  xlab("Betweenness centrality") +
  ylab("Traffic per day") +
  theme_minimal()


# Compute a linear regression model where highway type predicts traffic
categorical <- lm(per_day ~ highway + 0, data = joined_data)
rmse_categorical <- sqrt(mean(residuals(categorical)^2)) 

# Plot the mean traffic per highway type 
ggplot(joined_data, aes(x = highway, y = per_day)) +
  geom_boxplot() +
  stat_summary(fun = mean, geom = "point", col = "pink1") + 
  xlab("Betweenness centrality") +
  ylab("Traffic per day") +
  theme_minimal()

# Compute a linear regression model where log btw and highway type predict traffic 
multivariate <- lm(per_day ~ log(btw) + highway, data = joined_data)
rmse_multivariate <- sqrt(mean(residuals(multivariate)^2))

multivariate_m <- multivariate$coefficients["log(btw)"]
multivariate_b <- multivariate$coefficients["(Intercept)"]

multivariate_bs <- c(multivariate_b, 
                     multivariate_b + multivariate$coefficients["highwayliving_street"],
                     multivariate_b + multivariate$coefficients["highwaypath"],
                     multivariate_b + multivariate$coefficients["highwayresidential"],
                     multivariate_b + multivariate$coefficients["highwaysecondary"])

# Plot the regression lines 
ggplot(joined_data) +
  geom_point(aes(x = btw, y = per_day, colour = highway)) +
  geom_line(
    data = data.frame(x = seq(300, 1000000000, by = 100000)),
    aes(x = x, y = multivariate_m * log(x) + multivariate_bs[1], color = "highwayliving_street")) +
  geom_line(
    data = data.frame(x = seq(300, 1000000000, by = 100000)),
    aes(x = x, y = multivariate_m * log(x) + multivariate_bs[2], color = "highwaypath")) +
  geom_line(
    data = data.frame(x = seq(300, 1000000000, by = 100000)),
    aes(x = x, y = multivariate_m * log(x) + multivariate_bs[3], color = "highwayresidential")) +
  geom_line(
    data = data.frame(x = seq(300, 1000000000, by = 100000)),
    aes(x = x, y = multivariate_m * log(x) + multivariate_bs[4], color = "highwaysecondary")) +
  scale_x_continuous(trans = "log") +
  xlab("Betweenness centrality") +
  ylab("Traffic per day") +
  theme_minimal()

```


## Task 10
Compare the two models using at least one quantitative model comparison method. 

```{r}
# Compute the AIC and BIC
BIC <- c(BIC(linear), BIC(loglinear), BIC(categorical), BIC(multivariate))
AIC <- c(AIC(linear), AIC(loglinear), AIC(categorical), AIC(multivariate))

model_performance <- data.frame(model = c("linear", "loglinear", "categorical",
                                          "multivariate"),
                                BIC = BIC,
                                AIC = AIC)

# Visualise the AIC and BIC for all models in a table
flextable(model_performance)

```


## Task 11
You counted the number of accidents along each network edge in Task 8. Apply Poisson regression to predict the number of bike accidents along each edge based on the (potentially transformed) centrality measure you computed in Task 4. Based on the model’s prediction, visualize the predicted probability that no accident occurs along each network edge.

```{r}
joined_data_acc <- joined_data |> 
  filter(!is.na(count_acc))

poisson_model <- glm(count_acc ~ btw, data = joined_data_acc, family = "poisson")
summary(poisson_model)

# Retrieve coefficients
intercept_poisson <- poisson_model$coefficient[1]
slope_poisson <- poisson_model$coefficient[2]

lambda_hat <- predict(poisson_model, type = "response")
prob_no_accidents <- exp(-lambda_hat)


ggplot(joined_data_acc) +
  geom_sf(aes(color = prob_no_accidents), size = 1.5) +
  scale_color_viridis_c(name = "Predicted probability", option = "H") +
  labs(title = "Predicted probability that no accident occurs per edge")
```


# Part 5 Spatial Regression
## Task 12
Construct a linear regression model to predict the number of accidents along network edges based on centrality measures and/or tree counts. You can freely transform variables and add other independent variables to seek a better model. Are the residuals spatially autocorrelated? (Note: Since the number of accidents is count data, Poisson regression makes more sense than simple linear regression, as you did in Task 11. However, use a simple linear regression model for this task so that you can compare the model performance against spatial regression models in Task 13).

```{r}
# first we plot the data
par(mfrow = c(1,1))
plot(joined_data_acc$count_acc~joined_data_acc$btw)
plot(joined_data_acc$count_acc~joined_data_acc$count_trees)

# transform variables, which could improve model fit

# plot data again

# Log-Transformation der Variablen
ggplot(joined_data_acc, aes(x = log(btw), y = log(count_acc))) +
  geom_point() +
  geom_smooth(method = "lm", color = "red") +  # Regressionslinie
  labs(title = "Log-transformierte Regressionsbeziehung", 
       x = "Log(Betweenness)", y = "Log(Anzahl Unfälle)") +
  theme_minimal()

# Quadratische Transformation
ggplot(joined_data_acc, aes(x = btw, y = count_acc)) +
  geom_point() +
  geom_smooth(method = "lm", formula = y ~ poly(x, 2), color = "red") +  # Quadratische Regressionslinie
  labs(title = "Quadratische Regression: Unfälle vs. Betweenness", 
       x = "Betweenness", y = "Anzahl Unfälle") +
  theme_minimal()

# Standardisierung der Variablen
joined_data_acc$btw_scaled <- scale(joined_data_acc$btw)
joined_data_acc$count_acc_scaled <- scale(joined_data_acc$count_acc)

# Streudiagramm der standardisierten Variablen
ggplot(joined_data_acc, aes(x = btw_scaled, y = count_acc_scaled)) +
  geom_point() +
  geom_smooth(method = "lm", color = "red") +
  labs(title = "Standardisierte Regressionsbeziehung", 
       x = "Standardisierte Betweenness", y = "Standardisierte Anzahl Unfälle") +
  theme_minimal()

# create different models
lm_betweenness <-lm(formula = count_acc ~ btw, data = joined_data_acc)
lm_trees <-lm(formula = count_acc ~ count_trees, data = joined_data_acc)
lm_betweenness_trees <-lm(formula = count_acc ~ btw + count_trees, data = joined_data_acc)

# plot lm_betweenness
ggplot(joined_data_acc, aes(x = btw, y = count_acc)) +
  geom_point(color = "black") +  
  geom_smooth(method = "lm", color = "blue") +  
  labs(x = "Betweenness centrality",
       y = "Amount of accidents") +
  theme_minimal()

par(mfrow = c(2, 2))
plot(lm_betweenness)

# plot lm_trees
ggplot(joined_data_acc, aes(x = count_trees, y = count_acc)) +
  geom_point(color = "black") +  
  geom_smooth(method = "lm", color = "blue") +  
  labs(x = "Amount of trees",
       y = "Amount of accidents") +
  theme_minimal()

par(mfrow = c(2, 2))
plot(lm_trees)

# plot lm_betweenness_trees
par(mfrow = c(2, 2))
plot(lm_betweenness_trees)

```

```{r}
#compare models and choose best model
BIC <- c(BIC(lm_betweenness), BIC(lm_trees), BIC(lm_betweenness_trees))
AIC <- c(AIC(lm_betweenness), AIC(lm_trees), AIC(lm_betweenness_trees))

model_performance <- data.frame(model = c("lm_betweenness", "lm_trees", "lm_betweenness_trees"),
                                BIC = BIC, 
                                AIC = AIC)

# Visualise the AIC and BIC for all models in a table
flextable(model_performance)
```

```{r}
# check for spatial autocorrelation of best model
# Extract residuals and bin them 
residuals_lm_btw <- residuals(lm_betweenness) |>
  as_tibble |>
  setNames("residuals") |>
  mutate(id = row_number()) |>
  mutate(binned_residuals = cut_interval(residuals, n = 8))

# Join with the polygons of upstate New York
joined_data_acc <- full_join(joined_data_acc, 
                             residuals_lm_btw, by = "id")

# Plot the residuals
ggplot(leukaemia_up_ny) +
  geom_sf(aes(fill = binned_residuals)) + 
  theme_minimal() +
  scale_fill_brewer(name='Residuals',
                    palette="PRGn") +
  theme(axis.title=element_blank())

# Contiguity neighbours
joined_data_acc_nb <- poly2nb(joined_data_acc)

# Binary spatial weights
joined_data_acc_weights <- nb2listw(joined_data_acc, style = "B")

# Moran's I 
morans_I_residuals <- lm.morantest(lm_leukaemia, listw = up_ny_weights,
                                   alternative = "greater")

morans_I_residuals
```

## Task 13
Apply a spatial regression model (spatial lag, spatial error, or both) using the same independent variables. Compare the spatial regression model to the simple linear regression model from Task 12.

```{r}
#spatial_lag
lag_joined <- lagsarlm (formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, 
                           data = joined_data_acc, listw = up_ny_weights)

summary(lag_joined)
```

```{r}
#spatial_error
ser_leukaemia  <- spautolm(formula = Z ~ PEXPOSURE + PCTAGE65P + PCTOWNHOME, data = joined_data_acc, 
                      listw = up_ny_weights)

summary(ser_leukaemia )
```


```{r}
#comparison of models
BIC <- c(BIC(linear), BIC(loglinear), BIC(categorical), BIC(multivariate), BIC(extreme))
AIC <- c(AIC(linear), AIC(loglinear), AIC(categorical), AIC(multivariate), AIC(extreme))

model_performance <- data.frame(model = c("linear", "loglinear", "categorical", 
                                          "multivariate", "extreme"),
                                BIC = BIC, 
                                AIC = AIC)

```


# Part 6: Spatial Autocorrelation
## Task 14
Define a (linear) mixed effects model to predict the number of accidents at an edge of the bicycle network from the (edge) centrality. You can freely transform variables and add other independent variables like the tree count. As groups for the random effects you can use the different road types (the highway property of the edges).
Note: Observations with NA values are simply omitted by the lmer() function. You could instead
treat them as a separate group using replace_na

```{r}

```

